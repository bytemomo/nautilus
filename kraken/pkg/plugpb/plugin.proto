syntax = "proto3";

package orca.plugin.v2;

import "google/protobuf/struct.proto";
import "google/protobuf/empty.proto";

option go_package = ".;plugpb";

// ======================================================================
// V2 API Design Philosophy
// ======================================================================
//
// V2 API uses bidirectional streaming to allow the runner to provide
// a connected conduit handle to the plugin, rather than having the
// plugin create its own connection.
//
// Key differences from V1:
// - Plugin receives connection I/O over gRPC stream
// - Runner manages connection lifecycle (dial, close)
// - Plugin focuses on protocol logic only
// - Same plugin code works over TCP, TLS, UDP, DTLS, etc.
//
// ======================================================================

// ------------------------------
// Connection Management
// ------------------------------

// Type of connection provided to the plugin
enum ConnectionType {
  CONNECTION_TYPE_UNSPECIFIED = 0;
  CONNECTION_TYPE_STREAM = 1;    // Stream-based (TCP, TLS, etc.)
  CONNECTION_TYPE_DATAGRAM = 2;  // Datagram-based (UDP, DTLS, etc.)
}

// Information about the established connection
message ConnectionInfo {
  ConnectionType type = 1;
  string local_addr = 2;         // e.g., "192.168.1.10:12345"
  string remote_addr = 3;        // e.g., "10.0.0.1:80"
  repeated string stack_layers = 4; // e.g., ["tcp", "tls"]
  map<string, string> metadata = 5; // Additional connection metadata
}

// Target information (for reporting purposes)
message Target {
  string host = 1;
  uint32 port = 2;
}

// ------------------------------
// Bidirectional Stream Messages
// ------------------------------

// Messages sent from Runner -> Plugin
message RunnerToPlugin {
  oneof message {
    // Initial message: provide connection and start execution
    StartExecution start = 1;

    // Data received from the conduit (response to ReadRequest)
    DataChunk data = 2;

    // End of stream / connection closed
    ConnectionClosed closed = 3;

    // Error occurred in the runner
    RunnerError error = 4;
  }
}

// Messages sent from Plugin -> Runner
message PluginToRunner {
  oneof message {
    // Plugin is ready to start
    Ready ready = 1;

    // Request to send data over the connection
    WriteRequest write = 2;

    // Request to receive data from the connection
    ReadRequest read = 3;

    // Plugin execution complete (with results)
    ExecutionComplete complete = 4;

    // Error occurred in the plugin
    PluginError error = 5;

    // Log message from plugin
    LogMessage log = 6;
  }
}

// ------------------------------
// Runner -> Plugin Messages
// ------------------------------

message StartExecution {
  ConnectionInfo connection = 1;
  Target target = 2;
  uint32 timeout_ms = 3;
  map<string, google.protobuf.Value> params = 4;
}

message DataChunk {
  uint64 request_id = 1;  // Matches ReadRequest.request_id
  bytes data = 2;
  bool eof = 3;           // True if end of stream reached
}

message ConnectionClosed {
  string reason = 1;
}

message RunnerError {
  string error = 1;
  bool fatal = 2;  // If true, plugin should abort
}

// ------------------------------
// Plugin -> Runner Messages
// ------------------------------

message Ready {
  string plugin_id = 1;
  string version = 2;
}

message WriteRequest {
  uint64 request_id = 1;  // Unique ID for this write operation
  bytes data = 2;
  uint32 timeout_ms = 3;
}

message ReadRequest {
  uint64 request_id = 1;  // Unique ID for this read operation
  uint32 max_bytes = 2;   // Maximum bytes to read
  uint32 timeout_ms = 3;
}

message ExecutionComplete {
  RunResult result = 1;
}

message PluginError {
  string error = 1;
  bool fatal = 2;  // If true, runner should abort
}

message LogMessage {
  int64 timestamp = 1;
  string level = 2;  // "debug", "info", "warn", "error"
  string message = 3;
}

// ------------------------------
// Result Types
// ------------------------------

message Finding {
  string id = 1;
  string module_id = 2;

  bool success = 3;
  string title = 4;
  string severity = 5;      // e.g., "info","low","medium","high","critical"
  string description = 6;

  map<string, string> evidence = 7;
  repeated string tags = 8;

  int64 timestamp = 9;
  Target target = 10;
}

message RunResult {
  Target target = 1;
  repeated Finding findings = 2;
  repeated string logs = 3;
}

// ------------------------------
// Metadata
// ------------------------------

message ModuleMetadata {
  string id = 1;
  string version = 2;
  repeated string required_tags = 3;
  repeated ConnectionType supported_connection_types = 4;
  map<string, string> default_params = 5;
  string description = 6;
}

// ------------------------------
// Service Definition
// ------------------------------

service OrcaPluginV2 {
  // V2 execution using bidirectional streaming for connection I/O
  //
  // Flow:
  // 1. Runner establishes connection (TCP, TLS, UDP, etc.)
  // 2. Runner opens stream and sends StartExecution
  // 3. Plugin sends Ready
  // 4. Plugin sends WriteRequest/ReadRequest as needed
  // 5. Runner responds with DataChunk for reads
  // 6. Plugin sends ExecutionComplete with results
  // 7. Runner closes stream and connection
  rpc RunWithConnection(stream RunnerToPlugin) returns (stream PluginToRunner);

  // Get plugin metadata
  rpc Metadata(google.protobuf.Empty) returns (ModuleMetadata);

  // Health check
  rpc Ping(google.protobuf.Empty) returns (google.protobuf.Empty);
}

// ------------------------------
// Alternative: Simplified RPC-based API
// ------------------------------

// For plugins that don't need fine-grained I/O control,
// a simpler RPC-based approach where the runner provides
// a connection handle ID that can be used in subsequent calls.

message ConnectionHandle {
  string handle_id = 1;  // Opaque connection handle
  ConnectionInfo info = 2;
}

message SimpleRunRequest {
  ConnectionHandle connection = 1;
  Target target = 2;
  uint32 timeout_ms = 3;
  map<string, google.protobuf.Value> params = 4;
}

message IORequest {
  string handle_id = 1;
  oneof operation {
    bytes write_data = 2;
    ReadRequest read_req = 3;
  }
  uint32 timeout_ms = 4;
}

message IOResponse {
  oneof result {
    WriteResult write_res = 1;
    bytes read_data = 2;
  }
}

message WriteResult {
  int64 bytes_written = 1;
}

// Alternative simpler service (can coexist with streaming version)
service OrcaPluginV2Simple {
  // Run with a pre-established connection handle
  rpc RunWithHandle(SimpleRunRequest) returns (RunResult);

  // Perform I/O operations on the connection handle
  rpc IO(IORequest) returns (IOResponse);

  // Get plugin metadata
  rpc Metadata(google.protobuf.Empty) returns (ModuleMetadata);
}

// ------------------------------
// Usage Notes
// ------------------------------

/*
 * Example Plugin Implementation (Streaming):
 *
 * func (s *MyPlugin) RunWithConnection(stream plugpb.OrcaPluginV2_RunWithConnectionServer) error {
 *     // 1. Receive StartExecution
 *     msg, _ := stream.Recv()
 *     start := msg.GetStart()
 *
 *     // 2. Send Ready
 *     stream.Send(&plugpb.PluginToRunner{
 *         Message: &plugpb.PluginToRunner_Ready{...},
 *     })
 *
 *     // 3. Send data (e.g., HTTP request)
 *     stream.Send(&plugpb.PluginToRunner{
 *         Message: &plugpb.PluginToRunner_Write{
 *             Write: &plugpb.WriteRequest{
 *                 RequestId: 1,
 *                 Data: []byte("GET / HTTP/1.0\r\n\r\n"),
 *             },
 *         },
 *     })
 *
 *     // 4. Request to read response
 *     stream.Send(&plugpb.PluginToRunner{
 *         Message: &plugpb.PluginToRunner_Read{
 *             Read: &plugpb.ReadRequest{
 *                 RequestId: 2,
 *                 MaxBytes: 4096,
 *             },
 *         },
 *     })
 *
 *     // 5. Receive data
 *     msg, _ = stream.Recv()
 *     data := msg.GetData()
 *
 *     // 6. Process and create findings...
 *     findings := analyzeSomething(data.Data)
 *
 *     // 7. Send results
 *     stream.Send(&plugpb.PluginToRunner{
 *         Message: &plugpb.PluginToRunner_Complete{
 *             Complete: &plugpb.ExecutionComplete{
 *                 Result: &plugpb.RunResult{
 *                     Findings: findings,
 *                 },
 *             },
 *         },
 *     })
 *
 *     return nil
 * }
 */
